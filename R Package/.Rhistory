ROCR::prediction(gatheredDT[Parameter == unique(gatheredDT$Parameter)[1]]$Value, gatheredDT[Parameter == unique(gatheredDT$Parameter)[1]]$Treatment)
pred = ROCR::prediction(gatheredDT[Parameter == unique(gatheredDT$Parameter)[1]]$Value, gatheredDT[Parameter == unique(gatheredDT$Parameter)[1]]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
AUC
gatheredDT[Parameter == unique(gatheredDT$Parameter)[1]]
sapply(unique(gatheredDT$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT)
sapply(unique(gatheredDT$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT[Parameter != InfInd])
sapply(unique(gatheredDT$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT[Parameter != 'InfInd'])
gatheredDT[Parameter != 'InfInd']
sapply(unique(gatheredDT$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT)
sapply(unique(gatheredDT[Parameter != 'InfInd']$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT)
mean(sapply(unique(gatheredDT[Parameter != 'InfInd']$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT))
sapply(unique(gatheredDT[Parameter %in% c('CellParametersPerimeter', '#End-pointvoxels')]$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT)
ourTrainingDataMetrics = c('CellParametersPerimeter', '#End-pointvoxels')
inputsAUCDT = testOptAUC[, c('Animal', 'Treatment', 'InfInd', ourTrainingDataMetrics, rownames(testOptInfIndAUC$`Metric Correlations`)), with = F]
gatheredDT = as.data.table(gather(inputsAUCDT, Parameter, Value, c('InfInd', ourTrainingDataMetrics, rownames(testOptInfIndAUC$`Metric Correlations`))))
featuresTable = spread(gatheredDT[, round(mean(Value),2), by = list(Parameter, Treatment)], Treatment, V1)
featuresTable
sapply(unique(gatheredDT$Parameter), function(x, gatheredDT) {
anova(aov(Value ~ Treatment, data = gatheredDT[Parameter == x]))[[5]][1]
}, gatheredDT)
sapply(unique(gatheredDT[Parameter != 'InfInd']$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT)
sapply(unique(gatheredDT[!(Parameter %in% c('InfInd', ourTrainingDataMetrics))]$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT)
sapply(unique(gatheredDT[Parameter %in% ourTrainingDataMetrics]$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT)
mean(sapply(unique(gatheredDT[Parameter %in% ourTrainingDataMetrics]$Parameter), function(x, gatheredDT) {
pred = ROCR::prediction(gatheredDT[Parameter == x]$Value, gatheredDT[Parameter == x]$Treatment)
perf = ROCR::performance(pred, "auc")
AUC = perf@y.values[[1]]
}, gatheredDT))
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
testOptInfIndP = constructInfInd(procDat = testOpt, method = 'p value')
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
##### Grab our testing data
# Specify our image storage and working directory for our LPS training data
imageStorageDirectory = '/Users/devin.clarke/Google Drive/Microglia Morphology Plugin - Attwell Data/Image Storage Directory'
workingDir = '/Users/devin.clarke/Google Drive/Microglia Morphology Plugin - Attwell Data/Working Directory/Output'
animalTreatmentIDs = getAnimalAndTreatmentIDs(imageStorageDirectory = imageStorageDirectory)
# Collate our  data
testData = morphPreProcessing(
pixelSize = 0.39,
morphologyWD = workingDir,
animalIDs = animalTreatmentIDs$animalIDs,
treatmentIDs = animalTreatmentIDs$treatmentIDs,
useFrac = T
)
##### Grab our training data
# If we're on mac, set the path to dropbox as in /Users/Devin/ and the github
# path as in /Users/Devin/Documents else set dropPath in windows to E:/
if(.Platform$OS.type == "unix") {
dropPath = file.path("", "Users", "devin.clarke")
gitPath = file.path("", "Users", "devin.clarke", "Documents")
} else if (.Platform$OS.type == "windows") {
dropPath = file.path("E:")
}
# Add on the dropbox file structure to dropPath
dropPath = file.path(dropPath, "Dropbox (Brain Energy Lab)", "Everything")
# Here we source our dependent functions, PCACleanCols and get Results
functionsDir =
file.path('/Users/devin.clarke/Documents/GitHub', "ThesisCode", "Microglia-Analysis",
"MicrogliaMorphologyAnalysis Functions")
# If it's not sourced, source the function for binning a vector and getting
# out our info for each animal i.e. diet, sex, age etc.
find = c("microMorphBoundWeights")
locations =
c(file.path(functionsDir,"microMorphBoundWeights.R"))
for(index in 1:length(find)) {
if(!exists(find[index])) {
source(locations[index])
}
}
rm("find", "locations")
inVivoInfoFile = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoMouseInfo.csv")
inVivoWeightsLog = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoWeightsLog.csv")
boundWeights = microMorphBoundWeights(inVivoInfoFile, inVivoWeightsLog)
# Set the arguments needed for the preprocessing data
pixelSize = 0.58
morphologyWDSelection = file.path(dropPath, "Devin", "2P Data Analysis", "Microglial Morphology", "Output")
animalIDs = unique(boundWeights$Animal)
treatmentIDs = as.character(unique(boundWeights$Timepoint))
treatmentIDs = treatmentIDs[is.na(treatmentIDs)==F]
LPSGroups = c("D56", "LPS")
useFrac = T
otherExclusions = list("Col" = "Diet", "Cond" = "Control")
altMorphSelection = "/Users/devin.clarke/Dropbox (Brain Energy Lab)/Everything/Devin/2P Data Analysis/Microglial Morphology/Storage/Choice April 2019/Output"
## Train on LPS Data without HFD cells
lps_comp_data =
morphPreProcessingLegacy(
pixelSize = pixelSize, morphologyWD = altMorphSelection,
animalIDs = animalIDs, treatmentIDs = treatmentIDs,
useFrac = useFrac)
lps_to_save = lps_comp_data[(Treatment != 'D1')]
correctCellNo <- function(inputDT) {
output_to_save = copy(inputDT)
cellNames = sapply(output_to_save$UniqueID, function(x) {
temp = substring(x, gregexpr('CANDIDATE', x))
substring(temp, 1, gregexpr('Y', temp)[[1]][1]+3)
})
uniqueCells = as.data.table(unique(cellNames))
uniqueCells[, CellNo := seq(1:nrow(uniqueCells))]
output_to_save[, MaskNames := cellNames]
setkey(uniqueCells, V1)
output_to_save[, CellNo := NULL]
setkey(output_to_save, MaskNames)
output_to_save[uniqueCells, CellNo := CellNo]
output_to_save[, MaskNames := NULL]
return(output_to_save)
}
lps_to_save = correctCellNo(lps_to_save)
trainDataRaw = merge(lps_to_save, unique(boundWeights[, list(Animal, Diet)]), by = "Animal")
trainData = trainDataRaw[Diet == 'Control']
labCols = c(c("Animal", "CellNo", "TCSValue", "Treatment", "UniqueID"), otherExclusions$Col)
setnames(trainData, old = 'TCS', new = 'TCSValue', skip_absent = T)
infIndOut = constructInfInd(procDat = trainData, labCols = labCols)
##### Apply to our test data
indexMetrics = rownames(infIndOut$PCA$rotation)
setnames(testData,
old = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
new = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
trainLabelled = applyInfInd(infIndOut$PCA, trainData[TCSValue == infIndOut$`Optimal TCS`])
testLabelled = applyInfInd(infIndOut$PCA, testData[TCSValue == infIndOut$`Optimal TCS`])
testLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
testLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
ggplot(data = testLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = CellParametersPerimeter)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
ggplot(data = testLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = `#End-pointvoxels`)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
anova(aov(`#End-pointvoxels` ~ Treatment, data = testLabelled))
anova(aov(CellParametersPerimeter ~ Treatment, data = testLabelled))
anova(aov(SomaSize ~ Treatment, data = testLabelled))
#testLabelled$Cell = sapply(testLabelled$Animal, function(x) tail(strsplit(x, '_')[[1]], n = 1))
#testLabelled$Field = sapply(testLabelled$Animal, function(x) tail(strsplit(x, '_')[[1]], n = 2)[1])
#testLabelled[, CellID := paste(Condition, Cell, sep = '-')]
anova(aov(InfInd ~ Treatment, data = testLabelled))
testLabelled
anova(aov(InfInd ~ Treatment, data = testLabelled))
trainData
infIndOut$`Optimal TCS`
trainLabelled
trainData
trainData
lps_raw = lps_comp_data[(Treatment != 'D1')]
unique(lps_raw$Treatment)
lps_to_save = correctCellNo(lps_raw)
trainDataRaw = merge(lps_raw, unique(boundWeights[, list(Animal, Diet)]), by = "Animal")
trainData = trainDataRaw[Diet == 'Control']
labCols = c(c("Animal", "CellNo", "TCSValue", "Treatment", "UniqueID"), otherExclusions$Col)
setnames(trainData, old = 'TCS', new = 'TCSValue', skip_absent = T)
infIndOut = constructInfInd(procDat = trainData, labCols = labCols)
procDat = trainDataRaw[Diet == 'Control']
labCols = c(c("Animal", "CellNo", "TCSValue", "Treatment", "UniqueID"), otherExclusions$Col)
tableOut = list()
PCAOut = list()
dataOut = list()
addIndex = 1
noDesc = 1:15
# For each TCS value we have in our training data
for(currTCS in unique(procDat$TCS)) {
PCAOut[[currTCS]] = list()
# Get out gathered data for this TCS value
aggData = formatROCRInput(copy(procDat[TCS == currTCS]), labCols)
# Get out AUC values for every metric in our gathered data
ROCList = list()
for(currMetric in unique(aggData$Parameter)) {
ROCList[[currMetric]] = getROCValues(aggData, currMetric)
ROCList[[currMetric]]$Parameter = currMetric
}
paramByAuc = rbindlist(ROCList)
# Loop through whether we're using the 1st, 1st+2nd, 1st+2nd+3rd etc. best discriminators
for(howMany in noDesc) {
# Get the PCA of our inflammation index, and a table of evaluation metrics
infIndices = createEvaluateInfIndex(paramByAuc, howMany, method = 'AUC', aggData, labCols, 0.9)
spreadDat = as.data.table(spread(aggData, Parameter, Value))
spreadDat[, InfInd := predict(infIndices$PCAOut, newdata = spreadDat)[,1]]
spreadDat[, TCS := currTCS]
spreadDat[, Vals := howMany]
dataOut[[addIndex]] = spreadDat
# Return our inflammation index PCA and pval and AUC values
PCAOut[[currTCS]][[howMany]] = infIndices$PCAOut
tableOut[[addIndex]] = infIndices$tableOut
tableOut[[addIndex]][, TCS := currTCS]
tableOut[[addIndex]][, Vals := howMany]
tableOut[[addIndex]][, Metrics := paste(infIndices$chosenMetrics, collapse = ",")]
addIndex = addIndex+1
}
}
# Combine our tableOut tables into a single data.table
forComp = unique(rbindlist(tableOut))
labCols = c(c("Animal", "CellNo", "TCSValue", "Treatment", "UniqueID"), otherExclusions$Col)
procDat = trainDataRaw[Diet == 'Control']
labCols = c(c("Animal", "CellNo", "TCSValue", "Treatment", "UniqueID"), otherExclusions$Col)
tableOut = list()
PCAOut = list()
dataOut = list()
addIndex = 1
noDesc = 1:15
# For each TCS value we have in our training data
for(currTCS in unique(procDat$TCS)) {
PCAOut[[currTCS]] = list()
# Get out gathered data for this TCS value
aggData = formatROCRInput(copy(procDat[TCS == currTCS]), labCols)
# Get out AUC values for every metric in our gathered data
ROCList = list()
for(currMetric in unique(aggData$Parameter)) {
ROCList[[currMetric]] = getROCValues(aggData, currMetric)
ROCList[[currMetric]]$Parameter = currMetric
}
paramByAuc = rbindlist(ROCList)
# Loop through whether we're using the 1st, 1st+2nd, 1st+2nd+3rd etc. best discriminators
for(howMany in noDesc) {
# Get the PCA of our inflammation index, and a table of evaluation metrics
infIndices = createEvaluateInfIndex(paramByAuc, howMany, method = 'AUC', aggData, labCols, 0.9)
spreadDat = as.data.table(spread(aggData, Parameter, Value))
spreadDat[, InfInd := predict(infIndices$PCAOut, newdata = spreadDat)[,1]]
spreadDat[, TCS := currTCS]
spreadDat[, Vals := howMany]
dataOut[[addIndex]] = spreadDat
# Return our inflammation index PCA and pval and AUC values
PCAOut[[currTCS]][[howMany]] = infIndices$PCAOut
tableOut[[addIndex]] = infIndices$tableOut
tableOut[[addIndex]][, TCS := currTCS]
tableOut[[addIndex]][, Vals := howMany]
tableOut[[addIndex]][, Metrics := paste(infIndices$chosenMetrics, collapse = ",")]
addIndex = addIndex+1
}
}
# Combine our tableOut tables into a single data.table
forComp = unique(rbindlist(tableOut))
labCols = c(c("Animal", "CellNo", "TCS", "Treatment", "UniqueID"), otherExclusions$Col)
tableOut = list()
PCAOut = list()
dataOut = list()
addIndex = 1
noDesc = 1:15
# For each TCS value we have in our training data
for(currTCS in unique(procDat$TCS)) {
PCAOut[[currTCS]] = list()
# Get out gathered data for this TCS value
aggData = formatROCRInput(copy(procDat[TCS == currTCS]), labCols)
# Get out AUC values for every metric in our gathered data
ROCList = list()
for(currMetric in unique(aggData$Parameter)) {
ROCList[[currMetric]] = getROCValues(aggData, currMetric)
ROCList[[currMetric]]$Parameter = currMetric
}
paramByAuc = rbindlist(ROCList)
# Loop through whether we're using the 1st, 1st+2nd, 1st+2nd+3rd etc. best discriminators
for(howMany in noDesc) {
# Get the PCA of our inflammation index, and a table of evaluation metrics
infIndices = createEvaluateInfIndex(paramByAuc, howMany, method = 'AUC', aggData, labCols, 0.9)
spreadDat = as.data.table(spread(aggData, Parameter, Value))
spreadDat[, InfInd := predict(infIndices$PCAOut, newdata = spreadDat)[,1]]
spreadDat[, TCS := currTCS]
spreadDat[, Vals := howMany]
dataOut[[addIndex]] = spreadDat
# Return our inflammation index PCA and pval and AUC values
PCAOut[[currTCS]][[howMany]] = infIndices$PCAOut
tableOut[[addIndex]] = infIndices$tableOut
tableOut[[addIndex]][, TCS := currTCS]
tableOut[[addIndex]][, Vals := howMany]
tableOut[[addIndex]][, Metrics := paste(infIndices$chosenMetrics, collapse = ",")]
addIndex = addIndex+1
}
}
# Combine our tableOut tables into a single data.table
forComp = unique(rbindlist(tableOut))
trainLabelled = applyInfInd(PCAOut[[500]][[2]]$PCA, trainData[TCSValue == 500])
testLabelled = applyInfInd(PCAOut[[500]][[2]]$PCA, testData[TCSValue == 500])
testLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
testLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
ggplot(data = testLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = CellParametersPerimeter)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
ggplot(data = testLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = `#End-pointvoxels`)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
anova(aov(`#End-pointvoxels` ~ Treatment, data = testLabelled))
anova(aov(CellParametersPerimeter ~ Treatment, data = testLabelled))
anova(aov(SomaSize ~ Treatment, data = testLabelled))
PCAOut[[500]]
PCAOut[[500]][[2]]
trainLabelled = applyInfInd(PCAOut[[500]][[2]], trainData[TCSValue == 500])
testLabelled = applyInfInd(PCAOut[[500]][[2]], testData[TCSValue == 500])
testLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
testLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
ggplot(data = testLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = CellParametersPerimeter)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
ggplot(data = testLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = `#End-pointvoxels`)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
anova(aov(`#End-pointvoxels` ~ Treatment, data = testLabelled))
anova(aov(CellParametersPerimeter ~ Treatment, data = testLabelled))
anova(aov(SomaSize ~ Treatment, data = testLabelled))
anova(aov(InfInd ~ Treatment, data = testLabelled))
testData
testData[TCSValue == infIndOut$`Optimal TCS`]
unique(testLabelled$TCSValue)
anova(aov(InfInd ~ Treatment, data = testLabelled))
testOpt = copy(testData)
testOpt[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
testOpt[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
testOpt$TCSValue
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
testOpt[c(77, 78, 79, 80), ]
testOpt[c(77, 78, 79, 80, 49, 50, 51, 52), ]
load_all()
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
spread(inputDt, Parameter, Value)
as.data.table(spread(inputDt, Parameter, Value))[, unique(inputDt$Parameter), with = F]
cor(as.data.table(spread(inputDt, Parameter, Value))[, unique(inputDt$Parameter), with = F])
load_all()
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
load_all()
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
testOpt[TCS == 400]
testOpt[TCSValue == 400]
load_all()
# Collate our  data
testData = morphPreProcessing(
pixelSize = 0.39,
morphologyWD = workingDir,
animalIDs = animalTreatmentIDs$animalIDs,
treatmentIDs = animalTreatmentIDs$treatmentIDs,
useFrac = T
)
dir(path = morphologyWD, pattern = "fracLac", full.names = T,
recursive = F, ignore.case = T)
dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T)
sapply(dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(x, 'fracLac')[[1]][2]
)
sapply(dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(x, 'fracLac/')[[1]][2]
)
sapply(dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(strsplit(x, 'fracLac/')[[1]][2], '/')[[1]][1]
)
which.max(sapply(dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(strsplit(x, 'fracLac/')[[1]][2], '/')[[1]][1]
))
dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T)
latestFolder = which.max(
sapply(
dir(
path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(strsplit(x, 'fracLac/')[[1]][2], '/')[[1]][1]
))
latestFolder
dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T)[latestFolder]
load_all()
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
# Collate our  data
testData = morphPreProcessing(
pixelSize = 0.39,
morphologyWD = workingDir,
animalIDs = animalTreatmentIDs$animalIDs,
treatmentIDs = animalTreatmentIDs$treatmentIDs,
useFrac = T
)
infIndOut = constructInfInd(procDat = trainData, labCols = labCols)
##### Grab our training data
# If we're on mac, set the path to dropbox as in /Users/Devin/ and the github
# path as in /Users/Devin/Documents else set dropPath in windows to E:/
if(.Platform$OS.type == "unix") {
dropPath = file.path("", "Users", "devin.clarke")
gitPath = file.path("", "Users", "devin.clarke", "Documents")
} else if (.Platform$OS.type == "windows") {
dropPath = file.path("E:")
}
# Add on the dropbox file structure to dropPath
dropPath = file.path(dropPath, "Dropbox (Brain Energy Lab)", "Everything")
# Here we source our dependent functions, PCACleanCols and get Results
functionsDir =
file.path('/Users/devin.clarke/Documents/GitHub', "ThesisCode", "Microglia-Analysis",
"MicrogliaMorphologyAnalysis Functions")
# If it's not sourced, source the function for binning a vector and getting
# out our info for each animal i.e. diet, sex, age etc.
find = c("microMorphBoundWeights")
locations =
c(file.path(functionsDir,"microMorphBoundWeights.R"))
for(index in 1:length(find)) {
if(!exists(find[index])) {
source(locations[index])
}
}
rm("find", "locations")
inVivoInfoFile = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoMouseInfo.csv")
inVivoWeightsLog = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoWeightsLog.csv")
boundWeights = microMorphBoundWeights(inVivoInfoFile, inVivoWeightsLog)
# Set the arguments needed for the preprocessing data
pixelSize = 0.58
morphologyWDSelection = file.path(dropPath, "Devin", "2P Data Analysis", "Microglial Morphology", "Output")
animalIDs = unique(boundWeights$Animal)
treatmentIDs = as.character(unique(boundWeights$Timepoint))
treatmentIDs = treatmentIDs[is.na(treatmentIDs)==F]
LPSGroups = c("D56", "LPS")
useFrac = T
otherExclusions = list("Col" = "Diet", "Cond" = "Control")
altMorphSelection = "/Users/devin.clarke/Dropbox (Brain Energy Lab)/Everything/Devin/2P Data Analysis/Microglial Morphology/Storage/Choice April 2019/Output"
## Train on LPS Data without HFD cells
lps_comp_data =
morphPreProcessingLegacy(
pixelSize = pixelSize, morphologyWD = altMorphSelection,
animalIDs = animalIDs, treatmentIDs = treatmentIDs,
useFrac = useFrac)
lps_to_save = lps_comp_data[(Treatment != 'D1')]
correctCellNo <- function(inputDT) {
output_to_save = copy(inputDT)
cellNames = sapply(output_to_save$UniqueID, function(x) {
temp = substring(x, gregexpr('CANDIDATE', x))
substring(temp, 1, gregexpr('Y', temp)[[1]][1]+3)
})
uniqueCells = as.data.table(unique(cellNames))
uniqueCells[, CellNo := seq(1:nrow(uniqueCells))]
output_to_save[, MaskNames := cellNames]
setkey(uniqueCells, V1)
output_to_save[, CellNo := NULL]
setkey(output_to_save, MaskNames)
output_to_save[uniqueCells, CellNo := CellNo]
output_to_save[, MaskNames := NULL]
return(output_to_save)
}
lps_to_save = correctCellNo(lps_to_save)
trainDataRaw = merge(lps_to_save, unique(boundWeights[, list(Animal, Diet)]), by = "Animal")
trainData = trainDataRaw[Diet == 'Control']
labCols = c(c("Animal", "CellNo", "TCSValue", "Treatment", "UniqueID"), otherExclusions$Col)
setnames(trainData, old = 'TCS', new = 'TCSValue', skip_absent = T)
infIndOut = constructInfInd(procDat = trainData, labCols = labCols)
indexMetrics = rownames(infIndOut$PCA$rotation)
setnames(testData,
old = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
new = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
trainLabelled = applyInfInd(infIndOut$PCA, trainData[TCSValue == infIndOut$`Optimal TCS`])
testLabelled = applyInfInd(infIndOut$PCA, testData[TCSValue == infIndOut$`Optimal TCS`])
testLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
testLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
anova(aov(InfInd ~ Treatment, data = testLabelled))
testOpt = copy(testData)
testOpt[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
testOpt[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
load_all()
testOptInfIndP = constructInfInd(procDat = testOpt, method = 'p value')
testOptAUC = applyInfInd(testOptInfIndAUC$PCA, testOpt[TCSValue == testOptInfIndAUC$`Optimal TCS`])
testOptP = applyInfInd(testOptInfIndP$PCA, testOpt[TCSValue == testOptInfIndP$`Optimal TCS`])
anova(aov(InfInd ~ Treatment, data = testOptAUC))
anova(aov(InfInd ~ Treatment, data = testOptP))
infIndOut$PCA$rotation
unique(testOptAUC$TCSValue)
mean(testOptAUC$SomaSize)
mean(testOptP$SomaSize)
testOpt[, mean(SomaSize), by = TCSValue]
testOpt
testOpt[, mean(MaskSize), by = TCSValue]
testOpt[, mean(MaskSize), by = list(TCSValue, Treatment)]
