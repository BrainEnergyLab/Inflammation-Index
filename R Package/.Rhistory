testOpt$TCSValue
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
testOpt[c(77, 78, 79, 80), ]
testOpt[c(77, 78, 79, 80, 49, 50, 51, 52), ]
load_all()
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
spread(inputDt, Parameter, Value)
as.data.table(spread(inputDt, Parameter, Value))[, unique(inputDt$Parameter), with = F]
cor(as.data.table(spread(inputDt, Parameter, Value))[, unique(inputDt$Parameter), with = F])
load_all()
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
load_all()
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
testOpt[TCS == 400]
testOpt[TCSValue == 400]
load_all()
# Collate our  data
testData = morphPreProcessing(
pixelSize = 0.39,
morphologyWD = workingDir,
animalIDs = animalTreatmentIDs$animalIDs,
treatmentIDs = animalTreatmentIDs$treatmentIDs,
useFrac = T
)
dir(path = morphologyWD, pattern = "fracLac", full.names = T,
recursive = F, ignore.case = T)
dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T)
sapply(dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(x, 'fracLac')[[1]][2]
)
sapply(dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(x, 'fracLac/')[[1]][2]
)
sapply(dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(strsplit(x, 'fracLac/')[[1]][2], '/')[[1]][1]
)
which.max(sapply(dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(strsplit(x, 'fracLac/')[[1]][2], '/')[[1]][1]
))
dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T)
latestFolder = which.max(
sapply(
dir(
path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T),
function(x) strsplit(strsplit(x, 'fracLac/')[[1]][2], '/')[[1]][1]
))
latestFolder
dir(path = main_fracLac_dir,
pattern = "Hull and Circle Results.txt", full.names = T,
recursive = T, ignore.case = T)[latestFolder]
load_all()
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
# Collate our  data
testData = morphPreProcessing(
pixelSize = 0.39,
morphologyWD = workingDir,
animalIDs = animalTreatmentIDs$animalIDs,
treatmentIDs = animalTreatmentIDs$treatmentIDs,
useFrac = T
)
infIndOut = constructInfInd(procDat = trainData, labCols = labCols)
##### Grab our training data
# If we're on mac, set the path to dropbox as in /Users/Devin/ and the github
# path as in /Users/Devin/Documents else set dropPath in windows to E:/
if(.Platform$OS.type == "unix") {
dropPath = file.path("", "Users", "devin.clarke")
gitPath = file.path("", "Users", "devin.clarke", "Documents")
} else if (.Platform$OS.type == "windows") {
dropPath = file.path("E:")
}
# Add on the dropbox file structure to dropPath
dropPath = file.path(dropPath, "Dropbox (Brain Energy Lab)", "Everything")
# Here we source our dependent functions, PCACleanCols and get Results
functionsDir =
file.path('/Users/devin.clarke/Documents/GitHub', "ThesisCode", "Microglia-Analysis",
"MicrogliaMorphologyAnalysis Functions")
# If it's not sourced, source the function for binning a vector and getting
# out our info for each animal i.e. diet, sex, age etc.
find = c("microMorphBoundWeights")
locations =
c(file.path(functionsDir,"microMorphBoundWeights.R"))
for(index in 1:length(find)) {
if(!exists(find[index])) {
source(locations[index])
}
}
rm("find", "locations")
inVivoInfoFile = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoMouseInfo.csv")
inVivoWeightsLog = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoWeightsLog.csv")
boundWeights = microMorphBoundWeights(inVivoInfoFile, inVivoWeightsLog)
# Set the arguments needed for the preprocessing data
pixelSize = 0.58
morphologyWDSelection = file.path(dropPath, "Devin", "2P Data Analysis", "Microglial Morphology", "Output")
animalIDs = unique(boundWeights$Animal)
treatmentIDs = as.character(unique(boundWeights$Timepoint))
treatmentIDs = treatmentIDs[is.na(treatmentIDs)==F]
LPSGroups = c("D56", "LPS")
useFrac = T
otherExclusions = list("Col" = "Diet", "Cond" = "Control")
altMorphSelection = "/Users/devin.clarke/Dropbox (Brain Energy Lab)/Everything/Devin/2P Data Analysis/Microglial Morphology/Storage/Choice April 2019/Output"
## Train on LPS Data without HFD cells
lps_comp_data =
morphPreProcessingLegacy(
pixelSize = pixelSize, morphologyWD = altMorphSelection,
animalIDs = animalIDs, treatmentIDs = treatmentIDs,
useFrac = useFrac)
lps_to_save = lps_comp_data[(Treatment != 'D1')]
correctCellNo <- function(inputDT) {
output_to_save = copy(inputDT)
cellNames = sapply(output_to_save$UniqueID, function(x) {
temp = substring(x, gregexpr('CANDIDATE', x))
substring(temp, 1, gregexpr('Y', temp)[[1]][1]+3)
})
uniqueCells = as.data.table(unique(cellNames))
uniqueCells[, CellNo := seq(1:nrow(uniqueCells))]
output_to_save[, MaskNames := cellNames]
setkey(uniqueCells, V1)
output_to_save[, CellNo := NULL]
setkey(output_to_save, MaskNames)
output_to_save[uniqueCells, CellNo := CellNo]
output_to_save[, MaskNames := NULL]
return(output_to_save)
}
lps_to_save = correctCellNo(lps_to_save)
trainDataRaw = merge(lps_to_save, unique(boundWeights[, list(Animal, Diet)]), by = "Animal")
trainData = trainDataRaw[Diet == 'Control']
labCols = c(c("Animal", "CellNo", "TCSValue", "Treatment", "UniqueID"), otherExclusions$Col)
setnames(trainData, old = 'TCS', new = 'TCSValue', skip_absent = T)
infIndOut = constructInfInd(procDat = trainData, labCols = labCols)
indexMetrics = rownames(infIndOut$PCA$rotation)
setnames(testData,
old = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
new = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
trainLabelled = applyInfInd(infIndOut$PCA, trainData[TCSValue == infIndOut$`Optimal TCS`])
testLabelled = applyInfInd(infIndOut$PCA, testData[TCSValue == infIndOut$`Optimal TCS`])
testLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
testLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
anova(aov(InfInd ~ Treatment, data = testLabelled))
testOpt = copy(testData)
testOpt[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
testOpt[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
testOptInfIndAUC = constructInfInd(procDat = testOpt, method = 'AUC')
load_all()
testOptInfIndP = constructInfInd(procDat = testOpt, method = 'p value')
testOptAUC = applyInfInd(testOptInfIndAUC$PCA, testOpt[TCSValue == testOptInfIndAUC$`Optimal TCS`])
testOptP = applyInfInd(testOptInfIndP$PCA, testOpt[TCSValue == testOptInfIndP$`Optimal TCS`])
anova(aov(InfInd ~ Treatment, data = testOptAUC))
anova(aov(InfInd ~ Treatment, data = testOptP))
infIndOut$PCA$rotation
unique(testOptAUC$TCSValue)
mean(testOptAUC$SomaSize)
mean(testOptP$SomaSize)
testOpt[, mean(SomaSize), by = TCSValue]
testOpt
testOpt[, mean(MaskSize), by = TCSValue]
testOpt[, mean(MaskSize), by = list(TCSValue, Treatment)]
##### Grab our testing data
# Specify our image storage and working directory for our LPS training data
attImageStorageDirectory = '/Users/devin.clarke/Google Drive/Microglia Morphology Plugin - Attwell Data/Image Storage Directory'
attWorkingDir = '/Users/devin.clarke/Google Drive/Microglia Morphology Plugin - Attwell Data/Working Directory/Output'
attAnimalTreatmentIDs = getAnimalAndTreatmentIDs(imageStorageDirectory = attImageStorageDirectory)
# Collate our  data
attTestData = morphPreProcessing(
pixelSize = 0.39,
morphologyWD = attWorkingDir,
animalIDs = attAnimalTreatmentIDs$animalIDs,
treatmentIDs = attAnimalTreatmentIDs$treatmentIDs,
useFrac = T
)
##### Grab our low res training data
# If we're on mac, set the path to dropbox as in /Users/Devin/ and the github
# path as in /Users/Devin/Documents else set dropPath in windows to E:/
if(.Platform$OS.type == "unix") {
dropPath = file.path("", "Users", "devin.clarke")
gitPath = file.path("", "Users", "devin.clarke", "Documents")
} else if (.Platform$OS.type == "windows") {
dropPath = file.path("E:")
}
# Add on the dropbox file structure to dropPath
dropPath = file.path(dropPath, "Dropbox (Brain Energy Lab)", "Everything")
# Here we source our dependent functions, PCACleanCols and get Results
functionsDir =
file.path('/Users/devin.clarke/Documents/GitHub', "ThesisCode", "Microglia-Analysis",
"MicrogliaMorphologyAnalysis Functions")
# If it's not sourced, source the function for binning a vector and getting
# out our info for each animal i.e. diet, sex, age etc.
find = c("microMorphBoundWeights")
locations =
c(file.path(functionsDir,"microMorphBoundWeights.R"))
for(index in 1:length(find)) {
if(!exists(find[index])) {
source(locations[index])
}
}
rm("find", "locations")
inVivoInfoFile = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoMouseInfo.csv")
inVivoWeightsLog = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoWeightsLog.csv")
boundWeights = microMorphBoundWeights(inVivoInfoFile, inVivoWeightsLog)
# Set the arguments needed for the preprocessing data
pixelSize = 0.58
morphologyWDSelection = file.path(dropPath, "Devin", "2P Data Analysis", "Microglial Morphology", "Output")
animalIDs = unique(boundWeights$Animal)
treatmentIDs = as.character(unique(boundWeights$Timepoint))
treatmentIDs = treatmentIDs[is.na(treatmentIDs)==F]
LPSGroups = c("D56", "LPS")
useFrac = T
otherExclusions = list("Col" = "Diet", "Cond" = "Control")
altMorphSelection = "/Users/devin.clarke/Dropbox (Brain Energy Lab)/Everything/Devin/2P Data Analysis/Microglial Morphology/Storage/Choice April 2019/Output"
## Train on LPS Data without HFD cells
lps_comp_data =
morphPreProcessingLegacy(
pixelSize = pixelSize, morphologyWD = altMorphSelection,
animalIDs = animalIDs, treatmentIDs = treatmentIDs,
useFrac = useFrac)
lps_to_save = lps_comp_data[(Treatment != 'D1')]
correctCellNo <- function(inputDT) {
output_to_save = copy(inputDT)
cellNames = sapply(output_to_save$UniqueID, function(x) {
temp = substring(x, gregexpr('CANDIDATE', x))
substring(temp, 1, gregexpr('Y', temp)[[1]][1]+3)
})
uniqueCells = as.data.table(unique(cellNames))
uniqueCells[, CellNo := seq(1:nrow(uniqueCells))]
output_to_save[, MaskNames := cellNames]
setkey(uniqueCells, V1)
output_to_save[, CellNo := NULL]
setkey(output_to_save, MaskNames)
output_to_save[uniqueCells, CellNo := CellNo]
output_to_save[, MaskNames := NULL]
return(output_to_save)
}
lps_to_save = correctCellNo(lps_to_save)
trainDataRaw = merge(lps_to_save, unique(boundWeights[, list(Animal, Diet)]), by = "Animal")
lowTrainData = trainDataRaw[Diet == 'Control']
labCols = c(c("Animal", "CellNo", "TCSValue", "Treatment", "UniqueID"), otherExclusions$Col)
setnames(lowTrainData, old = 'TCS', new = 'TCSValue', skip_absent = T)
lowInfIndOut = constructInfInd(procDat = lowTrainData, labCols = labCols)
##### Apply to our test data
indexMetrics = rownames(lowInfIndOut$PCA$rotation)
setnames(attTestData,
old = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
new = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
lowTrainLabelled = applyInfInd(lowInfIndOut$PCA, lowTrainData[TCSValue == infIndOut$`Optimal TCS`])
lowTestLabelled = applyInfInd(lowInfIndOut$PCA, attTestData[TCSValue == lowInfIndOut$`Optimal TCS`])
lowTestLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
lowTestLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
ggplot(data = lowTestLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = CellParametersPerimeter)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
ggplot(data = lowTestLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = `#End-pointvoxels`)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
anova(aov(`#End-pointvoxels` ~ Treatment, data = lowTestLabelled))
anova(aov(CellParametersPerimeter ~ Treatment, data = lowTestLabelled))
anova(aov(SomaSize ~ Treatment, data = lowTestLabelled))
anova(aov(InfInd ~ Treatment, data = lowTestLabelled))
lowTestLabelled[complete.cases(InfInd), list(mean(InfInd), sd(InfInd)), by = Treatment]
require(devtools)
load_all()
##### Grab our testing data
# Specify our image storage and working directory for our LPS training data
attImageStorageDirectory = '/Users/devin.clarke/Google Drive/Microglia Morphology Plugin - Attwell Data/Image Storage Directory'
attWorkingDir = '/Users/devin.clarke/Google Drive/Microglia Morphology Plugin - Attwell Data/Working Directory/Output'
attAnimalTreatmentIDs = getAnimalAndTreatmentIDs(imageStorageDirectory = attImageStorageDirectory)
# Collate our  data
attTestData = morphPreProcessing(
pixelSize = 0.39,
morphologyWD = attWorkingDir,
animalIDs = attAnimalTreatmentIDs$animalIDs,
treatmentIDs = attAnimalTreatmentIDs$treatmentIDs,
useFrac = T
)
##### Grab our low res training data
# If we're on mac, set the path to dropbox as in /Users/Devin/ and the github
# path as in /Users/Devin/Documents else set dropPath in windows to E:/
if(.Platform$OS.type == "unix") {
dropPath = file.path("", "Users", "devin.clarke")
gitPath = file.path("", "Users", "devin.clarke", "Documents")
} else if (.Platform$OS.type == "windows") {
dropPath = file.path("E:")
}
# Add on the dropbox file structure to dropPath
dropPath = file.path(dropPath, "Dropbox (Brain Energy Lab)", "Everything")
# Here we source our dependent functions, PCACleanCols and get Results
functionsDir =
file.path('/Users/devin.clarke/Documents/GitHub', "ThesisCode", "Microglia-Analysis",
"MicrogliaMorphologyAnalysis Functions")
# If it's not sourced, source the function for binning a vector and getting
# out our info for each animal i.e. diet, sex, age etc.
find = c("microMorphBoundWeights")
locations =
c(file.path(functionsDir,"microMorphBoundWeights.R"))
for(index in 1:length(find)) {
if(!exists(find[index])) {
source(locations[index])
}
}
rm("find", "locations")
inVivoInfoFile = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoMouseInfo.csv")
inVivoWeightsLog = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoWeightsLog.csv")
boundWeights = microMorphBoundWeights(inVivoInfoFile, inVivoWeightsLog)
# Set the arguments needed for the preprocessing data
pixelSize = 0.58
morphologyWDSelection = file.path(dropPath, "Devin", "2P Data Analysis", "Microglial Morphology", "Output")
animalIDs = unique(boundWeights$Animal)
treatmentIDs = as.character(unique(boundWeights$Timepoint))
treatmentIDs = treatmentIDs[is.na(treatmentIDs)==F]
LPSGroups = c("D56", "LPS")
useFrac = T
otherExclusions = list("Col" = "Diet", "Cond" = "Control")
altMorphSelection = "/Users/devin.clarke/Dropbox (Brain Energy Lab)/Everything/Devin/2P Data Analysis/Microglial Morphology/Storage/Choice April 2019/Output"
## Train on LPS Data without HFD cells
lps_comp_data =
morphPreProcessingLegacy(
pixelSize = pixelSize, morphologyWD = altMorphSelection,
animalIDs = animalIDs, treatmentIDs = treatmentIDs,
useFrac = useFrac)
lps_to_save = lps_comp_data[(Treatment != 'D1')]
correctCellNo <- function(inputDT) {
output_to_save = copy(inputDT)
cellNames = sapply(output_to_save$UniqueID, function(x) {
temp = substring(x, gregexpr('CANDIDATE', x))
substring(temp, 1, gregexpr('Y', temp)[[1]][1]+3)
})
uniqueCells = as.data.table(unique(cellNames))
uniqueCells[, CellNo := seq(1:nrow(uniqueCells))]
output_to_save[, MaskNames := cellNames]
setkey(uniqueCells, V1)
output_to_save[, CellNo := NULL]
setkey(output_to_save, MaskNames)
output_to_save[uniqueCells, CellNo := CellNo]
output_to_save[, MaskNames := NULL]
return(output_to_save)
}
lps_to_save = correctCellNo(lps_to_save)
trainDataRaw = merge(lps_to_save, unique(boundWeights[, list(Animal, Diet)]), by = "Animal")
lowTrainData = trainDataRaw[Diet == 'Control']
labCols = c(c("Animal", "CellNo", "TCSValue", "Treatment", "UniqueID"), otherExclusions$Col)
setnames(lowTrainData, old = 'TCS', new = 'TCSValue', skip_absent = T)
lowInfIndOut = constructInfInd(procDat = lowTrainData, labCols = labCols)
##### Apply to our test data
indexMetrics = rownames(lowInfIndOut$PCA$rotation)
setnames(attTestData,
old = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
new = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
lowTrainLabelled = applyInfInd(lowInfIndOut$PCA, lowTrainData[TCSValue == infIndOut$`Optimal TCS`])
lowTestLabelled = applyInfInd(lowInfIndOut$PCA, attTestData[TCSValue == lowInfIndOut$`Optimal TCS`])
lowTestLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
lowTestLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
ggplot(data = lowTestLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = CellParametersPerimeter)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
ggplot(data = lowTestLabelled[, c('Treatment', 'CellParametersPerimeter', '#End-pointvoxels'), with = F], aes(x = Treatment, y = `#End-pointvoxels`)) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x), geom = 'crossbar')
anova(aov(`#End-pointvoxels` ~ Treatment, data = lowTestLabelled))
anova(aov(CellParametersPerimeter ~ Treatment, data = lowTestLabelled))
anova(aov(SomaSize ~ Treatment, data = lowTestLabelled))
anova(aov(InfInd ~ Treatment, data = lowTestLabelled))
lowTestLabelled[complete.cases(InfInd), list(mean(InfInd), sd(InfInd)), by = Treatment]
require(RColorBrewer)
require(ggplot2)
# Grouped by timepoint
attwellCompPlot = ggplot(data = lowTestLabelled, aes(x = Treatment, y = InfInd, col = Treatment)) +
geom_point(size = 3) +
stat_summary(fun = mean, fun.min = function(x) mean(x) - sd(x), fun.max = function(x) mean(x) + sd(x),
geom = 'crossbar') +
theme_bw() +
scale_color_brewer(palette="Dark2") +
theme(legend.position = 'none',
axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.x = element_blank(), axis.text.y = element_blank())
attwellCompPlot
# Specify our image storage and working directory for our LPS training data
motImageStorageDirectory = '/Users/devin.clarke/Google Drive/Microglia Morphology Plugin - Motility Data/Image Storage/'
motLPSworkingDirectory = '/Users/devin.clarke/Google Drive/Microglia Morphology Plugin - Motility Data/LPS Working Directory/Output'
motAnimalTreatmentIDs = getAnimalAndTreatmentIDs(imageStorageDirectory = motImageStorageDirectory)
# Collate our lPS data
motLPSDt = morphPreProcessing(
pixelSize = 0.27,
morphologyWD = motLPSworkingDirectory,
animalIDs = motAnimalTreatmentIDs$animalIDs,
treatmentIDs = motAnimalTreatmentIDs$treatmentIDs,
useFrac = T
)
# Clean it up
motlpsData = copy(motLPSDt)
motlpsData[Treatment != 'LPS T1', Treatment := 'D56 T1']
LPSGroups = c('LPS T1', 'D56 T1')
# Get a vector of animal IDs that have only had control diet treatment
controlIDs = c("BK1L", "BR1R", "BT1L", "BU1L1R", "BX1R", "CE1L", "CE1R",  "CW2R",  "DARTH","SNOKE")
# Filter our data to only include control animals
motInDat = motlpsData[Treatment %in% LPSGroups & Animal %in% controlIDs]
# Use the AUC method to construct an inflammation index on this dataset
method = 'AUC'
motInfIndOut =
constructInfInd(procDat = motInDat,
method = method)
highTrainLabelled = applyInfInd(motInfIndOut$PCA, motInDat[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled = applyInfInd(motInfIndOut$PCA, attTestData[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
highTestLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
anova(aov(InfInd ~ Treatment, data = highTestLabelled))
highTestLabelled
highTestLabelled[, .N, by = Treatment]
highTestLabelled[complete.cases(InfInd), .N, by = Treatment]
motInfIndOut =
constructInfInd(procDat = motInDat[TCSValue == 300],
method = method)
highTrainLabelled = applyInfInd(motInfIndOut$PCA, motInDat[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled = applyInfInd(motInfIndOut$PCA, attTestData[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
highTestLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
anova(aov(InfInd ~ Treatment, data = highTestLabelled))
attTestData
setnames(attTestData,
old = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
new = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
highTestLabelled = applyInfInd(motInfIndOut$PCA, attTestData[TCSValue == motInfIndOut$`Optimal TCS`])
motInfIndOut$`Optimal TCS`
motInfIndOut$PCA$rotation
names(motInfIndOut$PCA$rotation)
rownames(motInfIndOut$PCA$rotation)
names(attTestData)
Intersect(rowsnames(motInfIndOut$PCA$rotation), names(attTestData))
intersect(rowsnames(motInfIndOut$PCA$rotation), names(attTestData))
intersect(rownames(motInfIndOut$PCA$rotation), names(attTestData))
rownames(motInfIndOut$PCA$rotation)[!intersect(rownames(motInfIndOut$PCA$rotation), names(attTestData))]
?intersect
intersect(rownames(motInfIndOut$PCA$rotation), names(attTestData))
rownames(motInfIndOut$PCA$rotation)[rownames(motInfIndOut$PCA$rotation) != intersect(rownames(motInfIndOut$PCA$rotation), names(attTestData))]
rownames(motInfIndOut$PCA$rotation)[!(rownames(motInfIndOut$PCA$rotation) %in% intersect(rownames(motInfIndOut$PCA$rotation), names(attTestData)))]
names(attTestData)
setnames(attTestData,
new = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
old = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
highTestLabelled = applyInfInd(motInfIndOut$PCA, attTestData[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
highTestLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
anova(aov(InfInd ~ Treatment, data = highTestLabelled))
motInfIndOut =
constructInfInd(procDat = motInDat[TCSValue == 500],
method = method)
setnames(attTestData,
new = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
old = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
highTrainLabelled = applyInfInd(motInfIndOut$PCA, motInDat[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled = applyInfInd(motInfIndOut$PCA, attTestData[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
highTestLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
anova(aov(InfInd ~ Treatment, data = highTestLabelled))
motInfIndOut =
constructInfInd(procDat = motInDat[TCSValue == 400],
method = method)
setnames(attTestData,
new = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
old = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
highTrainLabelled = applyInfInd(motInfIndOut$PCA, motInDat[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled = applyInfInd(motInfIndOut$PCA, attTestData[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
highTestLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
anova(aov(InfInd ~ Treatment, data = highTestLabelled))
motInfIndOut =
constructInfInd(procDat = motInDat,
method = 'p value')
setnames(attTestData,
new = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
old = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
highTrainLabelled = applyInfInd(motInfIndOut$PCA, motInDat[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled = applyInfInd(motInfIndOut$PCA, attTestData[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
highTestLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
anova(aov(InfInd ~ Treatment, data = highTestLabelled))
method = 'AUC'
motInfIndOut =
constructInfInd(procDat = motInDat[TCSValue == 300],
method = method)
setnames(attTestData,
new = c('MaximumNumberofIntersections', 'MaxIntersectionRadius', 'RamificationIndex(sampled)', 'CriticalRadius'),
old = c('Maxinters.', 'Maxinters.radius', 'Ramificationindex(sampled)', 'Criticalradius'),
skip_absent = T
)
highTrainLabelled = applyInfInd(motInfIndOut$PCA, motInDat[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled = applyInfInd(motInfIndOut$PCA, attTestData[TCSValue == motInfIndOut$`Optimal TCS`])
highTestLabelled[grepl('2017_05_07|2017_04_07', Animal), Treatment := 'WT']
highTestLabelled[grepl('2017_29_06|2017_28_06', Animal), Treatment := 'KO']
anova(aov(InfInd ~ Treatment, data = highTestLabelled))
