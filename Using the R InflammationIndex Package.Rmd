---
title: "Inflammation Index R Package"
output: rmarkdown::github_document
---

# Inflammation Index Package in R

## Step 1: Creating an Inflammation Index Based on Positive Control Conditions

In RStudio the InflammationIndex package can be installed first by installing and loading devtools, then installing the InflammationIndex package from GitHub

```{r, eval = F}
require(devtools)
install_github("BrainEnergyLab/Inflammation-Index")
require(InflammationIndex)

```

Now users should run the morphPreProcessing() function on the positive control data. Here they should specify the pixel size in microns (assuming a square pixel), and the morphologyWD argument should be a string that is a path to the output folder of the working directory of the ImageJ script. AnimalIDs should be a string vector of the names of the Animal folders in the image storage structure, and likewise for the TreatmentIDs argument. These treatment IDs should be the two positive control conditions (e.g. pre- and post-LPS) This function puts together all the output of the Fiji script analysis into a single data table where each row is a cell and each column is a morphological measure.

```{r, eval = F}
pixelSize = 0.58 # Pixel size in microns
morphologyWD = "/Microglial Morphology/Output" # Output directory of the MicroMorph.ijm script as a string
animalIDs = c('HIPP5', 'HIPP6', 'HIPP7') # Vector of strings identifying the names of the animals images were captured from and matching the names of the Animal level folders
treatmentIDs = c('Pre-LPS', 'Post-LPS') # Vector of strings identifying different treatments / timepoints and matching the names of the Treatment level folders
useFrac = T # Boolean indicating whether to use the output of the FracLac plugin
TCSExclude = NULL # String vector of mask sizes to exclude from the preprocessing function, can also take NULL
```

```{r, include = F}

# If our packages are not installed, install them
list.of.packages <- c("devtools", "data.table")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

require("devtools")
require("data.table")

list.of.packages <- c("InflammationIndex")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install_github("BrainEnergyLab/Inflammation-Index")

require("InflammationIndex")

# If we're on mac, set the path to dropbox as in /Users/Devin/ and the github
# path as in /Users/Devin/Documents else set dropPath in windows to E:/
if(.Platform$OS.type == "unix") {
  dropPath = file.path("", "Users", "devin.clarke1")
  gitPath = file.path("", "Users", "devin.clarke1", "Documents")
} else if (.Platform$OS.type == "windows") {
  dropPath = file.path("E:")
}

# Add on the dropbox file structure to dropPath
dropPath = file.path(dropPath, "Dropbox (Brain Energy Lab)", "Everything")

# If we're on window set gitPath to being within dropPath in the Devin folder
if(.Platform$OS.type == "windows") {
  gitPath = file.path(dropPath, "Devin")
}

# Add GitHub to the gitPath
gitPath = file.path(gitPath, "GitHub")

# Here we source our dependent functions, PCACleanCols and get Results
functionsDir = 
  file.path(gitPath, "ThesisCode", "Microglia-Analysis", 
            "MicrogliaMorphologyAnalysis Functions")

# If it's not sourced, source the function for binning a vector and getting 
# out our info for each animal i.e. diet, sex, age etc.
find = c("microMorphBoundWeights")
locations = 
  c(file.path(functionsDir,"microMorphBoundWeights.R"))

for(index in 1:length(find)) {
  if(!exists(find[index])) {
    source(locations[index])
  }
}

rm("find", "locations")

inVivoInfoFile = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoMouseInfo.csv")
inVivoWeightsLog = file.path(dropPath, "Devin", "HFD Data", "In Vivo Data", "InVivoWeightsLog.csv")

boundWeights = microMorphBoundWeights(inVivoInfoFile, inVivoWeightsLog)

# Set the arguments needed for the preprocessing data
pixelSize = 0.58
morphologyWD = file.path(dropPath, "Devin", "2P Data Analysis", "Microglial Morphology", "Output")

animalIDs = unique(boundWeights$Animal)[]
treatmentIDs = as.character(unique(boundWeights$Timepoint))
treatmentIDs = treatmentIDs[is.na(treatmentIDs)==F]
treatmentIDs = c('D56', 'LPS')
useFrac = T

```

```{r, cache = T}

output = 
  morphPreProcessing(
    pixelSize = pixelSize, morphologyWD = morphologyWD, 
    animalIDs = animalIDs, treatmentIDs = treatmentIDs,
    useFrac = useFrac)

```

```{r}

head(output)

```

Following this, users should run the constructInfInd() function, where inDat is set to the output of the morphPreProcessing() function, LPSGroups is a string vector (length of 2) of the TreatmentIDs that identify the positive control and control groups for the experiment (same as the treatmentIDs just fed into morphPreProcessing), method is the method used to identify the mask sizes that are best at discrminating inflammation from control groups (can use the smallest p value of comparisons, or the area under the curve of a receiver-operating characteristic (ROC) analysis). This function loops through each mask size value present, and first uses an ROC analysis to rank the morphological measures that are best at discriminating between inflammed/non-inflammed cells. Then, the function builds a composite index composed of the best discriminators at each mask size, and using the method specified to pick which mask size, and number of features included in the composite, provides the best discrimination of inflammed/non inflammed cells. This building of a composite measure is based on work by Heindl et al. (2018): https://doi.org/10.3389/fncel.2018.00106.

```{r, eval = F}
inDat = output # The output of the morphPreProcessing() function
LPSGroups = c('Pre-LPS', 'Post-LPS') # Vector of strings of the positive control conditions
method = 'p value' # The method to use to refine the inflammation index, can also take the value 'AUC
noDesc = 1:15 # A vector of integers where we compare inflammation indices made up of the N best descriptors and compare them
  # E.g. when noDesc = c(1,2,3) we compare the inflammation indices made up of the 1 best discriminators, to one made of the 2 best discriminators, to one made of the 3 best discrminators.

```

```{r, include = F}

LPSGroups = c('D56', 'LPS')
inDat = output
method = 'p value'
noDesc = 1:15

```

```{r}

infIndOut = 
  constructInfInd(inDat = inDat,
                  LPSGroups = LPSGroups,
                  method = method,
                  noDesc = 1:15)

```
