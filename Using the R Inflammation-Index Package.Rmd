---
output:
  md_document:
    variant: gfm
---

# Inflammation Index R Package

---

## Table of Contents
1. [Installation and Dependencies](#installation-and-dependencies)
2. [Use with the Microglia Morphology Analysis Fiji Plugin](#use-with-the-microglia-morphology-analysis-fiji-plugin)
    1. [Step 1: Loading in Data (morphPreProcessing() function)](#step-1-loading-in-data-morphpreprocessing-function)
        - [Retrieving IDs from the Fiji Plugin Folder Structure](#retrieving-ids-from-the-fiji-plugin-folder-structure)
    2. [Step 2: Constructing the Inflammation Index (constructInfInd() function)](#step-2-constructing-the-inflammation-index-constructinfind-function)
    3. [Step 3: Apply the Inflammation Index to test data (applyInfInd())](#step-3-apply-the-inflammation-index-to-test-data-applyinfind)
    
---

## Installation and Dependencies

---

In R the InflammationIndex package can be installed first by
installing and loading devtools to enable installing packages directly from GitHub, 
then installing the InflammationIndex package from GitHub

```{r results = F}
require(devtools)
install_github("BrainEnergyLab/Inflammation-Index/R Package")
```

Then load in the package.

```{r results = F}
require(InflammationIndex)
```

```{r echo = F, results = F, warning = F, message = F}
require(data.table)
```

---

## Use with the Microglia Morphology Analysis Fiji Plugin

---

### Step 1: Loading in Data (morphPreProcessing() function)

After users have run the Microglia Morphology Analysis Fiji plugin ([see here](https://github.com/BrainEnergyLab/Inflammation-Index/blob/master/Using%20the%20Microglia%20Morphology%20Analysis%20ImageJ%20Plugin.md)), the ***morphPreProcessing()*** function can be used to read in and collate all the morphological
metrics extracted.This function requires users to specify:

- **pixelSize**: The pixel size in microns (assuming a square pixel)
- **morphologyWD**: The file path to the 'Output' folder of the 'working directory' of the Fiji plugin passed as a string 
- **animalIDs**: A string vector where each element is the ID of an animal that users want to extract data for
- **treatmentIDs**: A string vector where each element is the ID of the treatment applied that users want to extract data for

Optional inputs:

- **TCSExclude**: a numeric vector of mask size values that users want to exclude from the data collation
  - Defaults to NULL (no values are excluded)
- **useFrac**: a boolean that indicates whether the user wants to include data from FracLac in their collation
  - Defaults to False

The output of the function is a data.table where each row is a cell and the columns indicate
morphological metrics.

```{r}
 # Pixel size in microns
pixelSize = 0.58

# Output directory of the MicroMorph.ijm script as a string
morphologyWD = "/Microglial Morphology/Output" 

# Vector of strings identifying the names of the animals images were captured 
# from and matching the names of the Animal level folders
animalIDs = c('HIPP5', 'HIPP6', 'HIPP7')

# Vector of strings identifying different treatments and matching the names 
# of the Treatment level folders
treatmentIDs = c('Pre-LPS', 'Post-LPS') 

# Optional:

# Boolean indicating whether to use the output of the FracLac plugin
useFrac = T

# String vector of mask sizes to exclude from the preprocessing function, can also take NULL
TCSExclude = NULL
# Alternatively:
# TCSExclude = c(400, 500, 600)

```


#### Retrieving IDs from the Fiji Plugin Folder Structure


To avoid having to manually input the animal and treatment IDs, users can use the
***getAnimalAndTreatmentIDs()*** function to return a list, the only input is:

- **imageStorageDirectory**: the file path to the 'image storage directory' that users used with the
Fiji plugin, passed as a string

The function returns a list with two elements:

- **treatmentIDs**: a string vector of treatment IDs
- **animalIDs**: a string vector of animal IDs

These can be passed directly to the treatmentIDs and animalIDs arguments in morphPreProcessing().

```{r include = F}

imageStorageDirectory = '/Users/devin.clarke/Google Drive/Microglia Morphology Analysis Plugin - ImageJ Example Directory and Input Data; Plugin Run Complete/Image Storage Directory/'
morphologyWD = '/Users/devin.clarke/Google Drive/Microglia Morphology Analysis Plugin - ImageJ Example Directory and Input Data; Plugin Run Complete/Working Directory/Output'

imageStorageDirectoryOld = '/Users/devin.clarke/Dropbox (Brain Energy Lab)/Everything/2P data/Devin/'
morphologyWDOld = '/Users/devin.clarke/Dropbox (Brain Energy Lab)/Everything/Devin/2P Data Analysis/Microglial Morphology/Output/'

exampleData = '/Users/devin.clarke/Google Drive/Inflammation Index R Package Example Data/example_morphpreprocessing_output.csv'

```


Here we're using the 'Image Storage Directory' in the example data found at our [Fji example data directory](https://drive.google.com/drive/folders/1t96nDcn9MJm0WcCDIAtmUL9dnJo-L4Ar?usp=sharing)


```{r}

idList = InflammationIndex::getAnimalAndTreatmentIDs(imageStorageDirectory)
treatmentIDs = idList$treatmentIDs
animalIDs = idList$animalIDs

idList

```

Here we're using the 'Working Directory/Output' in the example data found at our [Fji example data directory](https://drive.google.com/drive/folders/17vDC6DvMFMrDnKlWLNMphE1dfXmUCAon?usp=sharing)

```{r}
output = 
  morphPreProcessing(
    pixelSize = pixelSize, morphologyWD = morphologyWD, 
    animalIDs = animalIDs, treatmentIDs = treatmentIDs,
    useFrac = useFrac)
```

The columns in the output table:

- **Animal**: animal ID 
  - These values match the values in the animalIDs input
- **Treatment**: treatment ID
  - These values match the values in the treatmentIDs input
- **TCSValue**:  The mask size value this row's metrics relate to
- **UniqueID**: is a unique identifier for each row (a combination of animal, treatment, mask size, and name of the mask file)
- **CellNo**: (second to last column) is an identifier for each cell that is duplicated if a cell
has measurements taken at multiple TCSValue levels. 

All other columns are morphological metrics.


```{r}
head(output)
```

---

### Step 2: Constructing the Inflammation Index (constructInfInd() function)

---

Once users have an output from the morphPreProcessing() function, they can use this
to generate an Inflammation Index based on training conditions using the constructInfInd() function.
This function takes one required arguments:

- **procDat**: this is the filtered data.table output by the morphPreProcessing() function that is limited to your positive control / training conditions in the 'Treatment' column
  - This table should have two unique values in the 'Treatment' column
  - This table should have multiple 'TCSValue' values as the function compares TCS value against one another
  to pick the value that provides the best morphological discrimination between training conditions
  
In addition there are four optional arguments:

- **method**: this is a string identifying which method users want to use to optimise the Inflammation Index
  - 'p value' uses the smallest p value
  - 'AUC' uses a ROC-AUC analysis
  -  Defaults to 'AUC'
- **noDesc**: this is an integer vector of the number of 'best' descriptors to compare to one another
  - Defaults to 5:15
- **labCols**: this is a string vector containing the names of non-metric columns that defaults to the identifier columns provided by morphPreProcessing():
  - Defaults to c(Animal, Treatment, TCSValue, UniqueID, CellNo)
- **correlationCutoff**: this is a decimal value that indicates the threshold at which highly correlated metrics will be dropped e.g a value of 0.9 means if two metrics correlate at this value or above, the worst performing one will be dropped from consideration
  - Defaults to 0.9
  
The function returns a list containing:
- **PCA**
  -  A PCA object, trained to be discriminate between the training conditions
- **Metrics Correlation**
  -  A correlation matrix of the metrics included in the PCA so users can see what was used, and how they relate
- **Optimal TCS**
  -  The TCS value identified as optimal for detecting differences in morphology between training conditions

```{r}
# A string vector indicating the treatment labels that ID our training data
LPSGroups = c('D56', 'LPS')

# The output of the morphPreProcessing() function filtered to only include our
# training data
inDat = output[Treatment %in% LPSGroups]
```


Here we're going to run this function on the example morphPreProccessing output table
found [here](https://drive.google.com/file/d/1dtgZZuBTPg-uJaWxZy8bOav8mSJs-msY/view?usp=sharing). 
It's worth noting that this data was collated with a legacy version of the morphPreProcessing function
and doesn't have any FracLac data included.


```{r include = F}

output = fread(exampleData)
setnames(output, old = c('TCS'), new = 'TCSValue')
inDat = output[Treatment %in% LPSGroups]

```

```{r}

head(inDat)

```

The constructInfInd() function will print out the mask size and number of descriptors
that created the Inflammation Index that was most sensitive to the differences in morphology
between the positive control conditions according to the method passed in the method argument. It will
also print the descriminators that were retained after cleaning (removing variants of the same metrics, removing highly correlated metrics) and these are the ones included in the index. Finally, it prints the value (AUC or p value) of the index's ability to discriminate between training conditions.


```{r}
infIndOut = 
  constructInfInd(procDat = inDat)
```

The returned correlation matrix may also be of interest to users.

```{r}
infIndOut$`Metric Correlations`
```

---

### Step 3: Apply the Inflammation Index to test data (applyInfInd())

---

Users can use the applyInfInd() function to generate an Inflammation Index for novel
data using the PCA object output by constructInfInd(). All this dataset needs to have is the same
metrics that were available in the training dataset, and data collected at the identified optimal TCS value. 
The value of the Inflammation Index for each cell is added as the column 'InfInd'.

Here the $`Optimal TCS` value returned from constructInfInd can come in handy for automating the process.

```{r}
dataWithInfIndex = applyInfInd(infIndOut$PCA, output[TCSValue == infIndOut$`Optimal TCS`])
head(dataWithInfIndex[, list(Animal, Treatment, TCSValue, CellNo, InfInd)])
```

